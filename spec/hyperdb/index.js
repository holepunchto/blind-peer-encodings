// This file is autogenerated by the hyperdb compiler
/* eslint-disable camelcase */

const { IndexEncoder, c, b4a } = require('hyperdb/runtime')
const { version, getEncoding, setVersion } = require('./messages.js')

const versions = { schema: version, db: 0 }

const helpers0 = require('../../lib/db-actions.js')

// '@blind-peer/auth' collection key
const collection0_key = new IndexEncoder([], { prefix: 0 })

function collection0_indexify(record) {
  return []
}

// '@blind-peer/auth' value encoding
const collection0_enc = getEncoding('@blind-peer/auth')

// '@blind-peer/auth' reconstruction function
function collection0_reconstruct(schemaVersion, keyBuf, valueBuf) {
  setVersion(schemaVersion)
  const state = { start: 0, end: valueBuf.byteLength, buffer: valueBuf }
  const record = collection0_enc.decode(state)
  return record
}
// '@blind-peer/auth' key reconstruction function
function collection0_reconstruct_key(keyBuf) {
  return {}
}

// '@blind-peer/auth'
const collection0 = {
  name: '@blind-peer/auth',
  id: 0,
  version: 0,
  encodeKey(record) {
    const key = []
    return collection0_key.encode(key)
  },
  encodeKeyRange({ gt, lt, gte, lte } = {}) {
    return collection0_key.encodeRange({
      gt: gt ? collection0_indexify(gt) : null,
      lt: lt ? collection0_indexify(lt) : null,
      gte: gte ? collection0_indexify(gte) : null,
      lte: lte ? collection0_indexify(lte) : null
    })
  },
  encodeValue(schemaVersion, collectionVersion, record) {
    setVersion(schemaVersion)
    const state = { start: 0, end: 0, buffer: null }
    collection0_enc.preencode(state, record)
    state.buffer = b4a.allocUnsafe(state.end)
    collection0_enc.encode(state, record)
    return state.buffer
  },
  trigger: null,
  reconstruct: collection0_reconstruct,
  reconstructKey: collection0_reconstruct_key,
  indexes: [],
  decodedVersion: 0
}

// '@blind-peer/digest' collection key
const collection1_key = new IndexEncoder([], { prefix: 1 })

function collection1_indexify(record) {
  return []
}

// '@blind-peer/digest' value encoding
const collection1_enc = getEncoding('@blind-peer/digest')

// '@blind-peer/digest' reconstruction function
function collection1_reconstruct(schemaVersion, keyBuf, valueBuf) {
  setVersion(schemaVersion)
  const state = { start: 0, end: valueBuf.byteLength, buffer: valueBuf }
  const record = collection1_enc.decode(state)
  return record
}
// '@blind-peer/digest' key reconstruction function
function collection1_reconstruct_key(keyBuf) {
  return {}
}

// '@blind-peer/digest'
const collection1 = {
  name: '@blind-peer/digest',
  id: 1,
  version: 0,
  encodeKey(record) {
    const key = []
    return collection1_key.encode(key)
  },
  encodeKeyRange({ gt, lt, gte, lte } = {}) {
    return collection1_key.encodeRange({
      gt: gt ? collection1_indexify(gt) : null,
      lt: lt ? collection1_indexify(lt) : null,
      gte: gte ? collection1_indexify(gte) : null,
      lte: lte ? collection1_indexify(lte) : null
    })
  },
  encodeValue(schemaVersion, collectionVersion, record) {
    setVersion(schemaVersion)
    const state = { start: 0, end: 0, buffer: null }
    collection1_enc.preencode(state, record)
    state.buffer = b4a.allocUnsafe(state.end)
    collection1_enc.encode(state, record)
    return state.buffer
  },
  trigger: null,
  reconstruct: collection1_reconstruct,
  reconstructKey: collection1_reconstruct_key,
  indexes: [],
  decodedVersion: 0
}

// '@blind-peer/cores' collection key
const collection2_key = new IndexEncoder([IndexEncoder.BUFFER], { prefix: 2 })

function collection2_indexify(record) {
  const a = record.key
  return a === undefined ? [] : [a]
}

// '@blind-peer/cores' value encoding
const collection2_enc = getEncoding('@blind-peer/core/hyperdb#2')

// '@blind-peer/cores' reconstruction function
function collection2_reconstruct(schemaVersion, keyBuf, valueBuf) {
  const key = collection2_key.decode(keyBuf)
  setVersion(schemaVersion)
  const state = { start: 0, end: valueBuf.byteLength, buffer: valueBuf }
  const record = collection2_enc.decode(state)
  record.key = key[0]
  return record
}
// '@blind-peer/cores' key reconstruction function
function collection2_reconstruct_key(keyBuf) {
  const key = collection2_key.decode(keyBuf)
  return {
    key: key[0]
  }
}

// '@blind-peer/cores'
const collection2 = {
  name: '@blind-peer/cores',
  id: 2,
  version: 0,
  encodeKey(record) {
    const key = [record.key]
    return collection2_key.encode(key)
  },
  encodeKeyRange({ gt, lt, gte, lte } = {}) {
    return collection2_key.encodeRange({
      gt: gt ? collection2_indexify(gt) : null,
      lt: lt ? collection2_indexify(lt) : null,
      gte: gte ? collection2_indexify(gte) : null,
      lte: lte ? collection2_indexify(lte) : null
    })
  },
  encodeValue(schemaVersion, collectionVersion, record) {
    setVersion(schemaVersion)
    const state = { start: 0, end: 0, buffer: null }
    collection2_enc.preencode(state, record)
    state.buffer = b4a.allocUnsafe(state.end)
    collection2_enc.encode(state, record)
    return state.buffer
  },
  trigger: null,
  reconstruct: collection2_reconstruct,
  reconstructKey: collection2_reconstruct_key,
  indexes: [],
  decodedVersion: 0
}

// '@blind-peer/cores-by-referrer' collection key
const index3_key = new IndexEncoder([IndexEncoder.BUFFER, IndexEncoder.UINT, IndexEncoder.BUFFER], {
  prefix: 3
})

// '@blind-peer/cores-by-referrer' has the following schema defined key map
const index3_map = helpers0.mapByReferrer

function index3_indexify(record) {
  const arr = []

  const a0 = record.referrer
  if (a0 === undefined) return arr
  arr.push(a0)

  const a1 = record.updated
  if (a1 === undefined) return arr
  arr.push(a1)

  const a2 = record.core
  if (a2 === undefined) return arr
  arr.push(a2)

  return arr
}

// '@blind-peer/cores-by-referrer'
const index3 = {
  name: '@blind-peer/cores-by-referrer',
  version: 0,
  id: 3,
  encodeKey(record) {
    return index3_key.encode(index3_indexify(record))
  },
  encodeKeyRange({ gt, lt, gte, lte } = {}) {
    return index3_key.encodeRange({
      gt: gt ? index3_indexify(gt) : null,
      lt: lt ? index3_indexify(lt) : null,
      gte: gte ? index3_indexify(gte) : null,
      lte: lte ? index3_indexify(lte) : null
    })
  },
  encodeValue: (record) => index3.collection.encodeKey(record),
  encodeIndexKeys(record, context) {
    const mapped = index3_map(record, context)
    const keys = new Array(mapped.length)
    for (let i = 0; i < mapped.length; i++) {
      const mappedRecord = mapped[i]
      keys[i] = index3_key.encode([mappedRecord.referrer, mappedRecord.updated, mappedRecord.core])
    }
    return keys
  },
  reconstruct: (keyBuf, valueBuf) => valueBuf,
  offset: collection2.indexes.length,
  collection: collection2
}
collection2.indexes.push(index3)

// '@blind-peer/cores-by-announce' collection key
const index4_key = new IndexEncoder([IndexEncoder.BUFFER], { prefix: 4 })

// '@blind-peer/cores-by-announce' has the following schema defined key map
const index4_map = helpers0.mapByAnnounce

function index4_indexify(record) {
  const a = record.core
  return a === undefined ? [] : [a]
}

// '@blind-peer/cores-by-announce'
const index4 = {
  name: '@blind-peer/cores-by-announce',
  version: 0,
  id: 4,
  encodeKey(record) {
    return index4_key.encode(index4_indexify(record))
  },
  encodeKeyRange({ gt, lt, gte, lte } = {}) {
    return index4_key.encodeRange({
      gt: gt ? index4_indexify(gt) : null,
      lt: lt ? index4_indexify(lt) : null,
      gte: gte ? index4_indexify(gte) : null,
      lte: lte ? index4_indexify(lte) : null
    })
  },
  encodeValue: (record) => index4.collection.encodeKey(record),
  encodeIndexKeys(record, context) {
    const mapped = index4_map(record, context)
    const keys = new Array(mapped.length)
    for (let i = 0; i < mapped.length; i++) {
      const mappedRecord = mapped[i]
      keys[i] = index4_key.encode([mappedRecord.core])
    }
    return keys
  },
  reconstruct: (keyBuf, valueBuf) => valueBuf,
  offset: collection2.indexes.length,
  collection: collection2
}
collection2.indexes.push(index4)

// '@blind-peer/cores-by-activity' collection key
const index5_key = new IndexEncoder([IndexEncoder.UINT, IndexEncoder.UINT, IndexEncoder.BUFFER], {
  prefix: 5
})

function index5_indexify(record) {
  const arr = []

  const a0 = record.priority
  if (a0 === undefined) return arr
  arr.push(a0)

  const a1 = record.active
  if (a1 === undefined) return arr
  arr.push(a1)

  const a2 = record.key
  if (a2 === undefined) return arr
  arr.push(a2)

  return arr
}

// '@blind-peer/cores-by-activity'
const index5 = {
  name: '@blind-peer/cores-by-activity',
  version: 0,
  id: 5,
  encodeKey(record) {
    return index5_key.encode(index5_indexify(record))
  },
  encodeKeyRange({ gt, lt, gte, lte } = {}) {
    return index5_key.encodeRange({
      gt: gt ? index5_indexify(gt) : null,
      lt: lt ? index5_indexify(lt) : null,
      gte: gte ? index5_indexify(gte) : null,
      lte: lte ? index5_indexify(lte) : null
    })
  },
  encodeValue: (record) => index5.collection.encodeKey(record),
  encodeIndexKeys(record, context) {
    return [index5_key.encode([record.priority, record.active, record.key])]
  },
  reconstruct: (keyBuf, valueBuf) => valueBuf,
  offset: collection2.indexes.length,
  collection: collection2
}
collection2.indexes.push(index5)

// '@blind-peer/cores-by-bytes-allocated' collection key
const index6_key = new IndexEncoder([IndexEncoder.UINT, IndexEncoder.BUFFER], { prefix: 6 })

function index6_indexify(record) {
  const arr = []

  const a0 = record.bytesAllocated
  if (a0 === undefined) return arr
  arr.push(a0)

  const a1 = record.key
  if (a1 === undefined) return arr
  arr.push(a1)

  return arr
}

// '@blind-peer/cores-by-bytes-allocated'
const index6 = {
  name: '@blind-peer/cores-by-bytes-allocated',
  version: 0,
  id: 6,
  encodeKey(record) {
    return index6_key.encode(index6_indexify(record))
  },
  encodeKeyRange({ gt, lt, gte, lte } = {}) {
    return index6_key.encodeRange({
      gt: gt ? index6_indexify(gt) : null,
      lt: lt ? index6_indexify(lt) : null,
      gte: gte ? index6_indexify(gte) : null,
      lte: lte ? index6_indexify(lte) : null
    })
  },
  encodeValue: (record) => index6.collection.encodeKey(record),
  encodeIndexKeys(record, context) {
    return [index6_key.encode([record.bytesAllocated, record.key])]
  },
  reconstruct: (keyBuf, valueBuf) => valueBuf,
  offset: collection2.indexes.length,
  collection: collection2
}
collection2.indexes.push(index6)

const collections = [collection0, collection1, collection2]

const indexes = [index3, index4, index5, index6]

module.exports = { versions, collections, indexes, resolveCollection, resolveIndex }

function resolveCollection(name) {
  switch (name) {
    case '@blind-peer/auth':
      return collection0
    case '@blind-peer/digest':
      return collection1
    case '@blind-peer/cores':
      return collection2
    default:
      return null
  }
}

function resolveIndex(name) {
  switch (name) {
    case '@blind-peer/cores-by-referrer':
      return index3
    case '@blind-peer/cores-by-announce':
      return index4
    case '@blind-peer/cores-by-activity':
      return index5
    case '@blind-peer/cores-by-bytes-allocated':
      return index6
    default:
      return null
  }
}
